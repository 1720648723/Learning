# CPP 基础语法

[参考文档菜鸟教程](https://www.runoob.com/cplusplus/cpp-strings.html)
**面试考点：指针、引用、运算符重载**

****
* **命名空间（namespace）**
  
  您可能会写一个名为 xyz() 的函数，在另一个可用的库中也存在一个相同的函数 xyz()。这样，编译器就无法判断您所使用的是哪一个 xyz() 函数。因此，引入了 命名空间 这个概念，专门用于解决上面的问题，它可作为附加信息来区分不同库中相同名称的函数、类、变量等。
  
  ```c++
  //<iostream> 这是我们要用到的库，作者也没有很好的理解这个文件和 std 命名空间的具体关系，之后会找找书，了解一下底层构造。
  #include <iostream> 
  using namespace std;//像例子那样调用会很麻烦，所以直接把前缀写出来，直接用就可以了。
  // using std::cout 只为一个函数声明，只有这一个函数可以直接用。
  //cout << "申明部分函数的命名空间"<< std::endl;
  
  namespace first_space{// 自定义的第一个命名空间
     void func(){
        cout << "Inside first_space" << endl;
     }
  }
  
  namespace second_space{// 自定义的第二个命名空间
     void func(){
        cout << "Inside second_space" << endl;
     }
  }
  int main (){
     first_space::func();// 调用第一个命名空间中的函数
     second_space::func(); // 调用第二个命名空间中的函数
     return 0;
  }
  ```
  
* **问：在 C 语言中，语句 int a = 016，那么十进制 a 是多少？**

* **答**：0 开头表示八进制，a 为 14。
****
### 运算符的使用
* **问：C 语言中的三目运算符的返回值？**

* **答**：**count  <<  ( x > y )  ?  x : y;** 返回 0 或 1，即真和假，只有 **z = ( x > y )  ?  x : y;** 才返回较大值。应该是运算符优先级的问题，**<<**  优先级高于 **?**
  [参考博客](https://blog.csdn.net/arbel/article/details/7294247)

  ```c++
  //问：输出是多少？
  int main()
  {
      int a = 1,b = 2,m = 0,n = 0,k;
      k = ( n = b < a ) && ( m = a ) ;
      printf("%d,%d\n",k,m);
      return 0;
  }
  //答：0，0 运算符的运行方式，&& 运算符，左边是 0 ，直接返回 0 ，左边是 1 则直接返回右边的布尔值。
  ```
****
### 宏的使用

  ```c++
  #include<stdio.h>
  #define SUM(x) 3*x*x+1 //关键字 define
  int main()
  {
      int i=5,j=8;
      printf("%d\n",SUM(i+j));
  }
  //输出64，宏的使用，代码编译的时候，宏会替换为表达式，即 （3 * i + j * i + j + 1）= 64。
  ```
****
### 字符串

* **第一种**：C++ 风格的字符串起源于 C 语言，并在 C++ 中继续得到支持。字符串实际上是使用 null 字符 '\0' 终止的一维字符数组。因此，一个以 null 结尾的字符串，包含了组成字符串的字符。下面示例长度为 6；

  ```c++
  char greeting[] = "Hello";//字符串长度为6，以'\0'结尾。
  ```

  赋值可以使用函数  **strcpy(S1,S2)** 将 S2 赋值到 S1。

* **第二种**：C++ 标准库提供了 string 类类型，推荐此种，比较容易理解。
****
### 指针和引用

* **指针 [ * ]**：是一个变量，其值为另一个变量的地址，即内存的地址。

* **(&)[取地址运算符]**：获取某个变量的地址；( * )[地址访问运算符]:访问某个地址的值；
  在变量声明的时候，如果没有确切的地址可以赋值，为指针变量赋一个 NULL 值是一个良好的编程习惯。赋为 NULL 值的指针被称为空指针。NULL 指针是一个定义在标准库中值为零的常量。

  ```c++
  int var = 100;
  int *pt = NULL; //没有 null 也可以，但养成好习惯嘛。
  pt = &var;
  int *ppt = &pt
  **pt;//二级指针，地址里包含的值还是一个地址,这样可以找到变量 var 的值。
  ```
  指向指针的指针是一种多级间接寻址的形式，或者说是一个指针链。通常，一个指针包含一个变量的地址。当我们定义一个指向指针的指针时，第一个指针包含了第二个指针的地址，第二个指针指向包含实际值的位置。

***

* **引用 [ & ]**：引用变量是一个别名，也就是说，它是某个已存在变量的另一个名字。一旦把引用初始化为某个变量，就可以使用该引用名称或变量名称来指向变量。通过使用引用来替代指针，会使 C++ 程序更容易阅读和维护。

  ```c++
  int a;
  int& b = a;//b 是 a 的引用，此时 a，b 同值。
  //一、最常见的 引用作为参数 用法
  void swap(int& x, int& y)
  {
     int temp;
     temp = x; /* 保存地址 x 的值 */
     x = y;    /* 把 y 赋值给 x */
     y = temp; /* 把 x 赋值给 y  */
     return;
  }
  //二、引用作为返回值 用法
  double vals[] = {10.1, 12.6, 33.1, 24.1, 50.0};
  double& setValues( int i )
  {
    return vals[i];   // 返回第 i 个元素的引用，注意作用域，不要返回局部变量的引用。
  }
  setValues(0) = 100 //函数放在左边，重新赋值。
  ```

* **问：在 C++ 中，引用和指针的区别？**
* **答**：1. 引用总是指向一个对象，指针可能不指向对象。
2. 引用不能用 const 修饰，而指针可以。
3. 引用创建时必须初始化，而指针则可以在任何时候被初始化。
4. 引用和指针都可以被重新赋值，错误：指针可以被重新赋值，一旦引用被初始化为一个对象，就不能被指向到另一个对象。
****
### 基本概念
* **输出函数 cout，cerr，clog**
  **cout**：经过缓冲后输出，默认情况下是显示器。缓冲区的目的，就是减少刷屏的次数——比如，你的程序输出圣经中的一篇文章。不带缓冲的话，就会每写一个字母，就输出一个字母，然后刷屏。有了缓冲，你将看到若干句子“同时”就出现在了屏幕上（由内存翻新到显存，然后刷新屏幕）。
  **cerr**：不经过缓冲而直接输出，一般用于迅速输出出错信息。因为有时候怕内存满了这种错误，不直接输出就没地方放了。
  **clog**：也是输出标准错误流（这点儿和 cerr 是一样的），貌似平时很少用到这个啊。
  [参考博客](https://blog.csdn.net/bsmmaoshenbo/article/details/50778068cout)
****
- **运算符和函数重载**
- **函数重载**：在同一个作用域内，可以声明几个功能类似的同名函数，但是这些同名函数的形式参数（指参数的个数、类型或者顺序）必须不同。您不能仅通过返回类型的不同来重载函数。
- **运算符重载[operator]**：与其他函数一样，重载运算符有一个返回类型和一个参数列表。大多数的重载运算符可被定义为普通的非成员函数或这被定义为类成员函数。如果我们定义上面的函数为类的非成员函数，那么我们需要为每次操作传递两个参数
