# JAVA-面向对象

**下面先介绍一下基本概念，然后再从我们熟知的封装、继承、多态三大部分进行讲解，不要死记概念，多多思考举出的问题**

**源文件声明**
一个源文件中只能有一个 public 类且源文件的名称应该和此类名相同，可以有多个非 public 类。此源文件属于哪个包，就在首行标明 package 包名；

**JAVA 包（package）**：包主要用来对 类和接口 进行分类。当开发 Java 程序时，可能编写成百上千的类，因此很有必要对类和接口进行分类。有关联关系的类放在一个源文件中，该文件属于哪个包，那么就在该源文件的首行写 package 语句，而不是你想象的那样将许多源文件打包。
1、为了更好地组织类，Java提供了包机制。包是类的容器，用于分隔类名空间。如果没有指定包名，所有的示例都属于一个默认的无名包。Java中的包一般均包含相关的类，java是跨平台的，所以java中的包和操作系统没有任何关系，java的包是用来组织文件的一种虚拟文件系统。
2、import 语句并没有将对应的java源文件拷贝到此处仅仅是引入，告诉编译器有使用外部文件，编译的时候要去读取这个外部文件。
3、Java提供的包机制与IDE 也没有关系。
4、定义在同一个包（package）内的类可以不经过 import 而直接相互使用。

**import**：在 Java 中，如果给出一个完整的限定名，包括包名、类名，那么 Java 编译器就可以很容易地定位到源代码或者类。Import 语句就是用来提供一个合理的路径，使得编译器可以找到某个类。如果源文件包含 import 语句，那么应该放在 package 语句和类定义之间。

### 封装
**4 种访问控制修饰符**
**共有的【public】**：对所有类可见。Java 程序的 main()  方法必须设置成公有的，否则，Java 解释器将不能运行该类。
**受保护的【protected】**：对同一包内的类和所有子类可见。
**默认的【default 】**：在同一包内可见，不使用任何修饰符。
**私有的【private】**：在同一类内可见。主要用来隐藏类的实现细节和保护类的数据。类和接口不能声明为 private。
访问范围：【public】> 【protected】> 【default 】> 【private】
![访问修饰符](../../pics/java访问修饰符.png)

**非访问修饰符：static、final**
为了实现一些其他的功能，Java也提供了许多非访问修饰符。
**static 修饰符**：用来创建类方法和类变量，这里叫**类方法**，不叫静态方法。
1、类的静态成员与类直接相关，与对象无关，在一个类的所有实例之间共享同一个静态成员
2、静态成员函数中不能调用非静态成员
3、非静态成员函数中可以调用静态成员
4、常量成员不能修改，静态成员变量必须初始化，但可以修改（例如我们常利用静态成员变量统计某个函数的调用次数）

**final  修饰符**：用来修饰类、方法和变量，final修饰的类不能够被继承，如String类是不可变类，修饰的方法不能被继承类重新定义，修饰的变量为常量，是不可修改的。

```java
public static final int BOXWIDTH = 10; 
//声明一个常量，不可变，默认关键字是 default

/*
在类方法（静态方法）中调用本类的类方法可直接调用。 实例方法也叫做对象方法。
类方法是属于整个类的，而实例方法是属于类的某个对象的。
由于类方法是属于整个类的，并不属于类的哪个对象，所以类方法的方法体中不能有与类的对象有关的内容。即类方法体有如下限制： 
(1) 类方法中不能引用对象变量；
(2) 类方法中不能调用类的对象方法；
(3) 在类方法中不能使用super、this关键字。
(4) 类方法不能被覆盖。 
如果违反这些限制，就会导致程序编译错误。
与类方法相比，对象方法几乎没有什么限制：
(1) 对象方法中可以引用对象变量，也可以引用类变量；
(2) 对象方法中可以调用类方法；
(3) 对象方法中可以使用super、this关键字。
*/
private static int numInstances = 0 ; //构造一个私有的静态变量
private static void addInstance(){ //构造一个私有的静态函数
	numInstances++;
}
```

**接口（interface）**：除非实现接口的类是抽象类，否则该类要定义接口中的所有方法。接口不能用于实例化对象，这是肯定的，都是抽象类嘛；接口没有构造方法；
**接口中的方法**：接口中的方法必须是抽象方法，且默认都是public和类不同（没有实现的方法如：public abstract void addPrice();其中abstract可以省略，方法前有其他修饰符都是错误的），这是和抽象类重要的区别之一；
**接口中的变量**接口不能包含成员变量（除了public static final），不要觉得可以像继承父类那样使用接口；**接口不应叫被继承，而应叫被实现；一个类可以同时实现多个接口，关键字是（implements）。

**问：static class 对么？**
static 不能用来修饰类，除非类是内部类，此时该类作为外部类的成员变量，可以用 static 修饰，否则一般类（class）只有四种访问控制修饰符 + abstract，final。

**问：不能用来修饰 接口 里 方法的有哪些关键字？**
答：不能用 private、protected，常用关键字public、abstract，当然 java8 新增 default 与 static 方法。


**abstract 修饰符**：用来创建抽象类和抽象方法。抽象类不能用来实例化对象，声明抽象类的唯一目的是为了将来对该类进行扩充。**如果一个类包含抽象方法，那么该类一定要声明为抽象类，但是一个抽象类不一定含有抽象方法**。抽象方法是一种没有任何实现的方法，该方法的的具体实现由子类提供。**任何继承抽象类的子类必须实现父类的所有抽象方法**，除非该子类也是抽象类。抽象类中也可以包含已经实现的方法，这是和接口的一个重要区别。抽象类中的抽象方法要加 abstract 关键字声明，但是接口中可以省略。

```java
abstract class Caravan{ //抽象类
	private double price;
	public abstract void addPrice(); //抽象方法
}
```


**synchronized 和 volatile 修饰符**：主要用于线程的编程。synchronized 关键字声明的方法同一时间只能被一个线程访问。Synchronized 修饰符可以应用于四个访问修饰符。
volatile 修饰的成员变量在每次被线程访问时，都强迫从共享内存中重读该成员变量的值。而且，当成员变量发生变化时，强迫线程将变化值回写到共享内存。这样在任何时刻，两个不同的线程总是看到某个成员变量的同一个值。一个 volatile 对象引用可能是 null。
```java
public synchronized void showDetails(){} 
```


### 继承（extends 或者 implements）
类继承是用 extends，而接口是用 implements，**虽然只能继承一个类，但是接口可以多继承**。
继承是 JAVA 面向对象编程技术的一块基石，因为它允许创建分等级层次的类。继承可以理解为一个对象从另一个对象获取属性的过程。在 JAVA 中，类的继承是单一继承，也就是说，一个子类只能拥有一个父类。B 是 A 的子类，B 的实例拥有 A 所有的成员变量，但对于 private 的成员变量 B 却没有访问权限，这保障了 A 的封装性。

**面：重载与重写的区别？**[参考博客](https://blog.csdn.net/linzhaojie525/article/details/55213010)
答：**重载**：1-是面向对象多态的一种主要实现方式。2-Java的方法重载，它们具有相同的函数名，但是参数或者返回值会不同，这就是我们常说的多态。**只修改返回值是无效的**。3-构造函数可以被重载但是不能被重写。

**重写**：注意：实现接口里的方法或者重写时，需要满足以下条件
三同一大一小：方法名、返回值类型、形参都要相同，访问权限>=重写前(并解释)，抛出异常<=重写前。
因此有以下约束。

1. 一大：
* 父类中声明为 public 的方法在子类中也必须为 public。
* 父类中声明为 protected 的方法在子类中要么声明为 protected，要么声明为 public。不能声明为private。
* 父类中声明为 private 的方法，不能够被调用。
2. 声明为final的方法不能被重写。声明为 static 的方法不能被重写，但是能够被再次声明。
3. 重写 的函数名和参数必须相同，而重载 函数名 相同，但是 参数 或者 返回值 必须有一个不同。
4.  @Override ：不写也可以，但是写了有如下好处，1-可以当注释用，方便阅读；2-编译器可以给你验证 @Override下面的方法名是否是你 **父类** 中所有的，如果没有则报错。例如，你如果没写 @Override，而你下面的方法名又写错了，这时你的编译器是可以编译通过的，因为编译器以为这个方法是你的子类中自己增加的方法。

**问：接口和抽象类有什么区别？**
答：抽象类是对概念的归纳，接口是对功能的归纳。继承抽象类可以先完成一个总体需求，再增加一个额外的功能，而接口则是强调对需求用户提供服务。需求不同，选择也会不一样。抽象方法和接口都不能定义方法体。
**解释**：为什么接口的属性默认是 public static final？
public: 使接口的实现类可以使用这个常量
static：static修饰就表示它属于类的，随的类的加载而存在的，如果是非static的话，就表示属于对象的，只有建立对象时才有它，而接口是不能建立对象的，所以接口的常量必须定义为static。
final：final修饰就是保证接口定义的常量不能被实现类去修改，如果没有final的话，由子类随意去修改的话，接口建立这个常量就没有意义了。


**问：子类将继承父类所有的数据域和方法？**
正确，在一个子类被创建的时候，首先会在内存中创建一个父类对象，然后在父类对象外部放上子类独有的属性，两者合起来形成一个子类的对象。所以所谓的继承使子类拥有父类所有的属性和方法其实可以这样理解，子类对象确实拥有父类对象中所有的属性和方法，但是父类对象中的私有属性和方法，子类是无法访问到的，只是拥有，但不能使用。就像有些东西你可能拥有，但是你并不能使用。所以子类对象是绝对大于父类对象的，所谓的子类对象只能继承父类非私有的属性及方法的说法是错误的。可以继承，只是无法访问到而已。

**问：子类可以继承和覆盖父类的类方法？**
答：static修饰的成员属于类成员，父类字段或方法只能被子类同名字段或方法遮蔽，不能被继承覆盖。

**instanceof 判断是否是继承关系**
```java
System.out.println(dog instanceof Animal); //左边是子类 右边是父类
```

**Obeject类是所有类的终极父类，任何类都是它的子类**

**问：final关键字的含义？**
答：final 修饰属性，那么此属性是常量不能被修改；final修饰方法，那么此方法不能被子类覆盖；final修饰类，那么这个类便不能被继承。


### 多态
向上转型：Animal animal = new Dog(); 会自动丢弃子类的方法，调用自己的方法时，如果子类有覆盖方法，则调用子类的，如果调用的方法是父类没有的，则编译会出错（所以如果使用父类进行调用一定是重写的方法！），具体参考下面的代码。
向下转型：Dog  dog = (Dog) animal; 要强转，调用子类重写的方法时会调用父类的方法。

```java
class Animal {//注意默认是 default，public类 只能有一个，且必须与文件名相同
	private int i; //私有成员不能被继承
	public void move(){
		System.out.println("动物可以移动");
	}
	public void move(int x){//重载了 move 方法
		System.out.println("动物移动了 " + x + " 米");
	}
}

class Dog extends Animal{ 
    @Override //不写也可以，但是写了有上面介绍的好处
	public void move(){
		super.move(); //调用父类方法，使用 super 关键字
		System.out.println("小狗可以跑");
	}
     public void methodB(){
        System.out.println("extern method");
    }
}

public class test{
	public static void main(String args[]){
		Animal a = new Animal();
		Animal b = new Dog();
		a.move(); //调用父类函数
		b.move(); //调用子类函数
        /*b.methodB(); 编译错误？
        多态：父类里没有的函数，在多态实现的时候不能出现。
        */
	}
}
```

**问：以下代码可以正常编译并运行么？**
```java
class Test{
	public static void hello(){System.out.println("hello");}
}
public class MyApp{
	public static void main(String[] args){
		Test test = null;
		test.hello();
	}
}

/*
是可以的！！！即使 Test test = null;也会加载静态方法，所以test包含Test类中的初始化数据，静态的，构造的，成员属性。额外，就算不是静态方法，编译也是可以通过的，只有在运行的时候才会报错。
如果一个成员被声明为static，它就能够在它的类的任何对象创建之前被访问，而不必引用任何对象（跟类是否有static修饰无关）。
*/
```

**问：构造函数能重载但不能覆盖？**
下面这个方法会报错么？
回答：会的，由于子类的构造函数什么都没写，所以系统会默认的添加super()；来调用Parent类中无参的构造函数，而父类中没有，则报错。
```java
class Parent{
	private int value;
	public Parent(int val){this.value = val;}
}
class SubClass extends Parent{
	public SubClass(int i){}
}
//可以在大括号中添加 super(i);
```


