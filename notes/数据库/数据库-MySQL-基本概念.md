# 数据库-MySQL-底层概念

JDBC[ java数据库连接(java DataBase Connectivity)]:由一组使用java语言编写的类与接口组成，可以为多种关系数据库提供统一访问。

**问：数据库事务的四大特性（ACID）以及事务的隔离级别（高频）？**
答：如果一个数据库声称支持事务的操作，那么该数据库必须要具备以下四个特性：
一、原子性（Atomicity）
　　原子性是指事务包含的所有操作要么全部成功，要么全部失败回滚。
二、一致性（Consistency）
　　拿转账来说，假设用户 A 和用户 B 两者的钱加起来一共是 5000，那么不管 A 和 B 之间如何转账，转几次账，事务结束后两个用户的钱相加起来应该还得是 5000，这就是事务的一致性。
三、隔离性（Isolation）
　　对于任意两个并发的事务 T1 和 T2，在事务 T1 看来，T2 要么在 T1 开始之前就已经结束，要么在 T1 结束之后才开始，这样每个事务都感觉不到有其他事务在并发地执行。
　　关于事务的隔离性数据库提供了多种隔离级别，稍后会介绍到。这里需要注意的是，上面提到的是第一种隔离级别，隔离性最高，但同样效率最低，后面还会后三种隔离级别。
四、持久性（Durability）
　　持久性是指一个事务一旦被提交了，那么对数据库中的数据的改变就是永久性的，即便是在数据库系统遇到故障的情况下也不会丢失提交事务的操作。

**隔离性是当多个用户（事务）并发访问数据库时，比如操作同一张表时，数据库为每一个用户开启的事务，不能被其他事务的操作所干扰，多个并发事务之间要相互隔离。如果不考虑事务的隔离性，会发生哪几种问题：**

1. 脏读[一事务在修改，二事务读，一事务回滚]
    例如：用户 A 向用户 B 转账 100 元，对应 SQL 命令如下
    update account set money=money+100 where name=’B’; (此时A通知B)
    update account set money=money - 100 where name=’A’;
　　当只执行第一条 SQL 时，A 通知 B 查看账户，B 发现确实钱已到账（此时即发生了脏读），而之后无论第二条 SQL 是否执行，只要该事务不提交，则所有操作都将回滚，那么当 B 以后再次查看账户时就会发现钱其实并没有转。脏读是指**在一个事务处理过程里读取了另一个未提交的事务中的数据**。当一个事务正在多次修改某个数据，而在这个事务中这多次的修改都还未提交，这时一个并发的事务来访问该数据，就会造成两个事务得到的数据不一致。所以 B 在 A 为完成事务的情况下不应该读到任何数据。
2. 不可重复读【一事务在读，二事务修改并提交了数据，一事务在读，注意和脏读的区别】
　　例如事务 T1 在读取某一数据，而事务 T2 立马修改了这个数据并且提交事务给数据库，事务 T1再次读取该数据就得到了不同的结果，发生了不可重复读。
　　不可重复读是指在对于数据库中的某个数据，一个事务范围内多次查询却返回了不同的数据值，这是由于在查询间隔，被另一个事务修改并提交了。
　　在某些情况下，不可重复读并不是问题，比如我们多次查询某个数据当然以最后查询得到的结果为主。但在另一些情况下就有可能发生问题。
　　**不可重复读和脏读的区别是：脏读是某一事务读取了另一个事务未提交的脏数据，而不可重复读则是读取了前一事务提交的数据。**
3. 虚读(幻读)【对批量数据处理的过程中，另一事务做了修改，注意和不可重复读的区别】
　　幻读是事务非独立执行时发生的一种现象。例如事务 T1 对一个表中所有的行的某个数据项做了从“1”修改为“2”的操作，这时事务 T2 又对这个表中插入了一行数据项，而这个数据项的数值还是为“1”并且提交给数据库。而操作事务 T1 的用户如果再查看刚刚修改的数据，会发现还有一行没有修改，其实这行是从事务 T2 中添加的，就好像产生幻觉一样，这就是发生了幻读。
　　**幻读和不可重复读都是读取了另一条已经提交的事务（这点就脏读不同），所不同的是不可重复读查询的都是同一个数据项，而幻读针对的是一批数据整体（比如数据的个数）。**

**现在来看看 MySQL 数据库为我们提供的四种隔离级别：**
[如何实现](https://blog.csdn.net/fg2006/article/details/6937413)
① Serializable (串行化)：可避免脏读、不可重复读、幻读的发生。
提供严格的事务隔离。它要求事务序列化执行，事务只能一个接着一个地执行，不能并发执行。此隔离级别可有效防止脏读、不可重复读和幻读。但这个级别可能导致大量的超时现象和锁竞争，在实际应用中很少使用。
② Repeatable read (可重复读)：可避免脏读、不可重复读的发生。
一个事务在执行过程中，可以访问其他事务成功提交的新插入的数据，但不可以访问成功修改的数据。读取数据的事务将会禁止写事务（但允许读事务），写事务则禁止任何其他事务。此隔离级别可有效防止不可重复读和脏读。
③ Read committed (读已提交)：可避免脏读的发生。
一个事务在执行过程中，既可以访问其他事务成功提交的新插入的数据，又可以访问成功修改的数据。读取数据的事务允许其他事务继续访问该行数据，但是未提交的写事务将会禁止其他事务访问该行。此隔离级别可有效防止脏读。
④ Read uncommitted (读未提交)：最低级别，任何情况都无法保证。一个事务在执行过程中，既可以访问其他事务未提交的新插入的数据，又可以访问未提交的修改数据。如果一个事务已经开始写数据，则另外一个事务不允许同时进行写操作，但允许其他事务读此行数据。此隔离级别可防止丢失更新。
　　以上四种隔离级别最高的是Serializable级别，最低的是Read uncommitted级别，当然级别越高，执行效率就越低。像Serializable这样的级别，就是以锁表的方式（类似于Java多线程中的锁）使得其他的线程只能在锁外等待，所以平时选用何种隔离级别应该根据实际情况。

　　在 MySQL 数据库中，支持上面四种隔离级别，默认的为 Repeatable read (可重复读)；而在Oracle 数据库中，只支持 Serializable (串行化)级别和 Read committed (读已提交)这两种级别，其中默认的为 Read committed 级别。　　
记住：设置数据库的隔离级别一定要是在开启事务之前！
　　如果是使用 JDBC 对数据库的事务设置隔离级别的话，也应该是在调用 Connection 对象的setAutoCommit(false) 方法之前。调用 Connection 对象的 setTransactionIsolation(level) 即可设置当前链接的隔离级别，至于参数 level，可以使用 Connection 对象的字段：
在JDBC中设置隔离级别的部分代码：

**问：数据库引擎（Innodb）的事务支持粒度？**
答：行级锁。

**问：如何实现乐观锁？**
乐观锁（ Optimistic Locking ） 相对悲观锁而言，乐观锁认为数据一般情况下不会造成冲突，所以只会在数据进行提交更新的时候，才会对数据是否冲突进行检测，如果发现冲突了，则返回错误的信息，让用户决定如何去做。那么我们如何实现乐观锁呢，
1.使用数据版本（Version）记录机制实现，这是乐观锁最常用的一种实现方式。何谓数据版本？即为数据增加一个版本标识，一般是通过为数据库表增加一个数字类型的 “version” 字段来实现。当读取数据时，将version字段的值一同读出，数据每更新一次，对此version值加一。当我们提交更新的时候，判断数据库表对应记录的当前版本信息与第一次取出来的version值进行比对，如果数据库表当前版本号与第一次取出来的version值相等，则予以更新，否则认为是过期数据。

[参考博客](https://blog.csdn.net/coolwriter/article/details/79794309)
**问：索引是什么？有什么作用以及优缺点（高频）？**
（1）是一种快速查询表中内容的机制，类似于新华字典的目录
（2）运用在表中某个些字段上，但存储时，独立于表之外，索引表把数据变成是有序的
快速定位到硬盘中的数据文件…

rowid的特点
（1）位于每个表中，但表面上看不见，例如：desc emp是看不见的
（2）只有在select中，显示写出rowid，方可看见
（3）它与每个表绑定在一起，表亡，该表的rowid亡，二张表rownum可以相同，但rowid必须是唯一的
（4）rowid是18位大小写加数字混杂体，唯一表代该条记录在DBF文件中的位置
（5）rowid可以参与=/like比较时，用”单引号将rowid的值包起来，且区分大小写
（6）rowid是联系表与DBF文件的桥梁

索引的特点
（1）索引一旦建立, Oracle 管理系统会对其进行自动维护, 而且由Oracle管理系统决定何时使用索引
（2）用户不用在查询语句中指定使用哪个索引
（3）在定义primary key或unique约束后系统自动在相应的列上创建索引
（4）用户也能按自己的需求，对指定单个字段或多个字段，添加索引
需要注意的是：Oracle是自动帮我们管理索引的，并且如果我们指定了primary key或者unique约束，系统会自动在对应的列上创建索引..

什么时候【要】创建索引
（1）表经常进行 SELECT 操作
（2）表很大(记录超多)，记录内容分布范围很广
（3）列名经常在 WHERE 子句或连接条件中出现

什么时候【不要】创建索引
（1）表经常进行 INSERT/UPDATE/DELETE 操作
（2）表很小(记录超少)
（3）列名不经常作为连接条件或出现在 WHERE 子句中

索引优缺点：
索引加快数据库的检索速度
索引降低了插入、删除、修改等维护任务的速度(虽然索引可以提高查询速度，但是它们也会导致数据库系统更新数据的性能下降，因为大部分数据更新需要同时更新索引)
唯一索引可以确保每一行数据的唯一性，通过使用索引，可以在查询的过程中使用优化隐藏器，提高系统的性能
索引需要占物理和数据空间

索引分类：
唯一索引：唯一索引不允许两行具有相同的索引值
主键索引：为表定义一个主键将自动创建主键索引，主键索引是唯一索引的特殊类型。主键索引要求主键中的每个值是唯一的，并且不能为空
聚集索引(Clustered)：表中各行的物理顺序与键值的逻辑（索引）顺序相同，每个表只能有一个
非聚集索引(Non-clustered)：非聚集索引指定表的逻辑顺序。数据存储在一个位置，索引存储在另一个位置，索引中包含指向数据存储位置的指针。可以有多个，小于249个


**问：三个范式是什么？**
首先要明确的是：满足着第三范式，那么就一定满足第二范式、满足着第二范式就一定满足第一范式
第一范式：字段是最小的的单元不可再分，学生信息组成学生信息表，有年龄、性别、学号等信息组成。这些字段都不可再分，所以它是满足第一范式
第二范式：满足第一范式,表中的字段必须完全依赖于全部主键而非部分主键。
其他字段组成的这行记录和主键表示的是同一个东西，而主键是唯一的，它们只需要依赖于主键，也就成了唯一的，学号为1024的同学，姓名为Java3y，年龄是22岁。姓名和年龄字段都依赖着学号主键。
第三范式：满足第二范式，非主键外的所有字段必须互不依赖
就是数据只在一个地方存储，不重复出现在多张表中，可以认为就是消除传递依赖
比如，我们大学分了很多系（中文系、英语系、计算机系……），这个系别管理表信息有以下字段组成：系编号，系主任，系简介，系架构。那我们能不能在学生信息表添加系编号，系主任，系简介，系架构字段呢？不行的，因为这样就冗余了，非主键外的字段形成了依赖关系(依赖到学生信息表了)！正确的做法是：学生表就只能增加一个系编号字段。

**问：什么是视图？以及视图的使用场景有哪些？**
视图是一种基于数据表的一种虚表
（1）视图是一种虚表
（2）视图建立在已有表的基础上, 视图赖以建立的这些表称为基表
（3）向视图提供数据内容的语句为 SELECT 语句,可以将视图理解为存储起来的 SELECT 语句
（4）视图向用户提供基表数据的另一种表现形式
（5）视图没有存储真正的数据，真正的数据还是存储在基表中
（6）程序员虽然操作的是视图，但最终视图还会转成操作基表
（7）一个基表可以有0个或多个视图
有的时候，我们可能只关系一张数据表中的某些字段，而另外的一些人只关系同一张数据表的某些字段,那么把全部的字段都都显示给他们看，这是不合理的。我们应该做到：他们想看到什么样的数据，我们就给他们什么样的数据，一方面就能够让他们只关注自己的数据，另一方面，我们也保证数据表一些保密的数据不会泄露出来，我们在查询数据的时候，常常需要编写非常长的SQL语句，几乎每次都要写很长很长，.上面已经说了，视图就是基于查询的一种虚表，也就是说，视图可以将查询出来的数据进行封装。那么我们在使用的时候就会变得非常方便。
值得注意的是：使用视图可以让我们专注与逻辑，但不提高查询效率

**问：drop、delete与truncate分别在什么场景之下使用？**
不再需要一张表的时候，用drop；
想删除部分数据行时候，用 delete，并且带上 where 子句；
保留表而删除所有数据的时候用 truncate




