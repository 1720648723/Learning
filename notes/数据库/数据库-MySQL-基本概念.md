# 数据库-MySQL-底层概念

JDBC[ java数据库连接(java DataBase Connectivity)]:由一组使用java语言编写的类与接口组成，可以为多种关系数据库提供统一访问。

**问：数据库事务的四大特性（ACID）以及事务的隔离级别（高频）？**
答：如果一个数据库声称支持事务的操作，那么该数据库必须要具备以下四个特性：
一、原子性（Atomicity）
　　原子性是指事务包含的所有操作要么全部成功，要么全部失败回滚。
二、一致性（Consistency）
　　拿转账来说，假设用户 A 和用户 B 两者的钱加起来一共是 5000，那么不管 A 和 B 之间如何转账，转几次账，事务结束后两个用户的钱相加起来应该还得是 5000，这就是事务的一致性。
三、隔离性（Isolation）
　　对于任意两个并发的事务 T1 和 T2，在事务 T1 看来，T2 要么在 T1 开始之前就已经结束，要么在 T1 结束之后才开始，这样每个事务都感觉不到有其他事务在并发地执行。
　　关于事务的隔离性数据库提供了多种隔离级别，稍后会介绍到。这里需要注意的是，上面提到的是第一种隔离级别，隔离性最高，但同样效率最低，后面还会后三种隔离级别。
四、持久性（Durability）
　　持久性是指一个事务一旦被提交了，那么对数据库中的数据的改变就是永久性的，即便是在数据库系统遇到故障的情况下也不会丢失提交事务的操作。

**隔离性是当多个用户并发访问数据库时，比如操作同一张表时，数据库为每一个用户开启的事务，不能被其他事务的操作所干扰，多个并发事务之间要相互隔离。如果不考虑事务的隔离性，会发生哪几种问题：**

1. 脏读[一事务在修改，二事务读，一事务回滚]
    例如：用户 A 向用户 B 转账 100 元，对应 SQL 命令如下
    update account set money=money+100 where name=’B’; (此时A通知B)
    update account set money=money - 100 where name=’A’;
　　当只执行第一条 SQL 时，A 通知 B 查看账户，B 发现确实钱已到账（此时即发生了脏读），而之后无论第二条 SQL 是否执行，只要该事务不提交，则所有操作都将回滚，那么当 B 以后再次查看账户时就会发现钱其实并没有转。脏读是指在一个事务处理过程里读取了另一个未提交的事务中的数据。当一个事务正在多次修改某个数据，而在这个事务中这多次的修改都还未提交，这时一个并发的事务来访问该数据，就会造成两个事务得到的数据不一致。所以 B 在 A 为完成事务的情况下不应该读到任何数据。
2. 不可重复读【一事务在读，二事务修改并提交了数据，一事务在读，注意和脏读的区别】
　　例如事务 T1 在读取某一数据，而事务 T2 立马修改了这个数据并且提交事务给数据库，事务 T1再次读取该数据就得到了不同的结果，发生了不可重复读。
　　不可重复读是指在对于数据库中的某个数据，一个事务范围内多次查询却返回了不同的数据值，这是由于在查询间隔，被另一个事务修改并提交了。
　　在某些情况下，不可重复读并不是问题，比如我们多次查询某个数据当然以最后查询得到的结果为主。但在另一些情况下就有可能发生问题。
　　**不可重复读和脏读的区别是：脏读是某一事务读取了另一个事务未提交的脏数据，而不可重复读则是读取了前一事务提交的数据。**
3. 虚读(幻读)【对批量数据处理的过程中，另一事务做了修改，注意和不可重复读的区别】
　　幻读是事务非独立执行时发生的一种现象。例如事务 T1 对一个表中所有的行的某个数据项做了从“1”修改为“2”的操作，这时事务 T2 又对这个表中插入了一行数据项，而这个数据项的数值还是为“1”并且提交给数据库。而操作事务 T1 的用户如果再查看刚刚修改的数据，会发现还有一行没有修改，其实这行是从事务 T2 中添加的，就好像产生幻觉一样，这就是发生了幻读。
　　**幻读和不可重复读都是读取了另一条已经提交的事务（这点就脏读不同），所不同的是不可重复读查询的都是同一个数据项，而幻读针对的是一批数据整体（比如数据的个数）。**

**现在来看看 MySQL 数据库为我们提供的四种隔离级别：**
[如何实现](https://blog.csdn.net/fg2006/article/details/6937413)
① Serializable (串行化)：可避免脏读、不可重复读、幻读的发生。
一事务开始就锁表，二事务不能读也不能写。
② Repeatable read (可重复读)：可避免脏读、不可重复读的发生。
一事务开始，二事务不能对其进行修改，但是可以读（整批数据）。会发生（幻读问题）
③ Read committed (读已提交)：可避免脏读的发生。
一事务开始，二事务可修改，不可读，会发生（不可重复读问题）
④ Read uncommitted (读未提交)：最低级别，任何情况都无法保证。
　　以上四种隔离级别最高的是Serializable级别，最低的是Read uncommitted级别，当然级别越高，执行效率就越低。像Serializable这样的级别，就是以锁表的方式（类似于Java多线程中的锁）使得其他的线程只能在锁外等待，所以平时选用何种隔离级别应该根据实际情况。

　　在 MySQL 数据库中，支持上面四种隔离级别，默认的为 Repeatable read (可重复读)；而在Oracle 数据库中，只支持 Serializable (串行化)级别和 Read committed (读已提交)这两种级别，其中默认的为 Read committed 级别。　　
记住：设置数据库的隔离级别一定要是在开启事务之前！
　　如果是使用 JDBC 对数据库的事务设置隔离级别的话，也应该是在调用 Connection 对象的setAutoCommit(false) 方法之前。调用 Connection 对象的 setTransactionIsolation(level) 即可设置当前链接的隔离级别，至于参数 level，可以使用 Connection 对象的字段：
在JDBC中设置隔离级别的部分代码：

**问：数据库引擎（Innodb）的事务支持粒度？**
答：行级锁。

**问：如何实现乐观锁？**
乐观锁（ Optimistic Locking ） 相对悲观锁而言，乐观锁认为数据一般情况下不会造成冲突，所以只会在数据进行提交更新的时候，才会对数据是否冲突进行检测，如果发现冲突了，则返回错误的信息，让用户决定如何去做。那么我们如何实现乐观锁呢，
1.使用数据版本（Version）记录机制实现，这是乐观锁最常用的一种实现方式。何谓数据版本？即为数据增加一个版本标识，一般是通过为数据库表增加一个数字类型的 “version” 字段来实现。当读取数据时，将version字段的值一同读出，数据每更新一次，对此version值加一。当我们提交更新的时候，判断数据库表对应记录的当前版本信息与第一次取出来的version值进行比对，如果数据库表当前版本号与第一次取出来的version值相等，则予以更新，否则认为是过期数据。




